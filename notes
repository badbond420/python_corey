# exception handling file:exception_handling.py
- syntax
try:
    # keep sensitive  initial code here
except:
    # handle exceptions
else:
    # if no exception, then write the logic here
finally:
    # no matter what, this block will execute,
    #  so its for cleaning up
- specific exception first, generic exception last.
- except FileNotFoundError as e; here from e we can get lots of details
- user defined exception detain in exception_handling.py file

# duck typing file:duck_typing.py
- the idea is ask for forgivness, if something go wrong. asuming somting will work.
- as you asume , you get a duck, and it will quack, if its a person, then ask forgiveness in code with try block.
- it faster, as u handle handle exception ones, rather than validation objects numerous time.
- race condition, is like quickly somthing changed, which is not excepted
ex:
    if os.access("file"):
        # quickly file deleted by other event
        # as no exception handling, unavoidable situation occured
        fh.open('file')
    else:
        print("file not accessable")
# generators file:generator_stuff.py
- yeild makes a function generator
- instade of creating and returnig a full list, use generater
- next(gen_obj) also works line a iterator
- keeping () instade of [] in list comprihansen, creates a generator.
- generatoer is way faster
- tuple(i for i in (1, 2, 3)) is tupple comprihanseion, as () taken for generator

# decoratoer file:decorator.py
- decorater is to dynamically modify a function.
- the idea is in decorater definition collect the return from the function,
  may modify result or do some ather action and re-return again. then return the function
- no mater , whether the decorated function return or not, but keeping return in decorater defination, doesnt harm
- decorater class: no need to call def inside def
- stacking decorater gets issu in geting name of the decorated function
- functools module will help in getting rid of it.
- decorater wit args, is like to add onemore level outer function, with arg, this arg to be
  handled in side inner definition
- this type of decorater , should be defined fully ones, before use.

ex: callable object
class my_callable_calss:
    def __call__(self, name):
        return "hi "+ name

my_callable_object = my_callable_calss()
print(my_callable_object("bibek"))

# Named tupple
! will revisit these collections later.

# classes and instances oop1 file:class_object.py
- encapsulaton is to pack attributes and methods in a single stuff, so called

# class variables file:class_variables.py
- unlike attributes/property class variables are bound to classes not object
- class variables are availables to all instances
- trying to modify class varible in instance level, adds a instance attribute overriding the class variable.
- ClassName.calss_var = 5 : also adds it to ClassName.__dict_ as class are also object.
- constants used in class are recomended to keep as class var, its eacier to access those const by class name
- object counter also one var, whic increased wit init method
- type(self).var evaluates to ClassName.var: its a good practice as in inheritance.




