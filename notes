# exception handling file:exception_handling.py
- syntax
try:
    # keep sensitive  initial code here
except:
    # handle exceptions
else:
    # if no exception, then write the logic here
finally:
    # no matter what, this block will execute,
    #  so its for cleaning up
- specific exception first, generic exception last.
- except FileNotFoundError as e; here from e we can get lots of details
- user defined exception detain in exception_handling.py file

# duck typing file:duck_typing.py
- the idea is ask for forgivness, if something go wrong. asuming somting will work.
- as you asume , you get a duck, and it will quack, if its a person, then ask forgiveness in code with try block.
- it faster, as u handle handle exception ones, rather than validation objects numerous time.
- race condition, is like quickly somthing changed, which is not excepted
ex:
    if os.access("file"):
        # quickly file deleted by other event
        # as no exception handling, unavoidable situation occured
        fh.open('file')
    else:
        print("file not accessable")
# generators file:generator_stuff.py
- yeild makes a function generator
- instade of creating and returnig a full list, use generater
- next(gen_obj) also works line a iterator
- keeping () instade of [] in list comprihansen, creates a generator.
- generatoer is way faster
- tuple(i for i in (1, 2, 3)) is tupple comprihanseion, as () taken for generator

# decoratoer file:decorator.py
- decorater is to dynamically modify a function.
- the idea is in decorater definition collect the return from the function,
  may modify result or do some ather action and re-return again. then return the function
- no mater , whether the decorated function return or not, but keeping return in decorater defination, doesnt harm
- decorater class: no need to call def inside def
- stacking decorater gets issu in geting name of the decorated function
- functools module will help in getting rid of it.
- decorater wit args, is like to add onemore level outer function, with arg, this arg to be
  handled in side inner definition
- this type of decorater , should be defined fully ones, before use.

ex: callable object
class my_callable_calss:
    def __call__(self, name):
        return "hi "+ name

my_callable_object = my_callable_calss()
print(my_callable_object("bibek"))

# Named tupple
! will revisit these collections later.

# classes and instances oop1 file:class_object.py
- encapsulaton is to pack attributes and methods in a single stuff, so called
-  in __init__ method definition  you can call other instance methods as well
- similarly in one ins method definition, you can call other inst methods as well.
ex:
class Emp:
    def __init__(self,fname,lname):
        self.first_name = fname
        self.last_name = lname
        self.email = fname + "." + lname + "@domain.com"
        self.full_name = self.get_name()

    def get_name(self):
        return self.first_name + " " + self.last_name


# class variables file:class_variables.py
- unlike attributes/property class variables are bound to classes not object
- class variables are availables to all instances
- trying to modify class varible in instance level, adds a instance attribute overriding the class variable.
- ClassName.calss_var = 5 : also adds it to ClassName.__dict_ as class are also object.
- constants used in class are recomended to keep as class var, its eacier to access those const by class name
- object counter also one var, whic increased wit init method
- type(self).var evaluates to ClassName.var in inst method: its a good practice as in inheritance.

# classmethod vs staticmethod file:class_static_method.py
- if we make a class variable a pvt variable, to manage that we will use class method.
- we cant address a pvt class variable with a instance method, as we cant use that inst method in class level.
- class methods are mostly used in factory method
- accessing class variables in static method has a problem in inheritance, as
- calling class methods from ins works fine.
ex:
    @staticmethod
    def about():
        print("This class is about {}!".format(Pets.name) # here we cant use type(self)

better method is:
    @classmethod
    def about():
        print("This class is about {}!".format(class.name) # it works well in
- class method is used for alternative constructers or factory methods.
- in datetime module, many factory methods are used
- let sey, someone using our class, and he gets constructer params as a string, so rather that, he writes code to handle the inputs
  and parr to class for creating a object, a pre defined factory function will do it.
- better to use staticmethod where no class/inst bound variables are used.
- static method can be asignd to a class from any randum function, thereafter it will behavie like static method
ex:
def addition(a , b):
    return a + b

Emp.addition = addition
print(Emp.addition(9,8))

- event thr ulternate , works too
ex:
junk_func = Emp.is_working_day
print(junk_func(my_date))

: inheritance file:inheritance.py
- in hertiance is used to re use code and functionality.
ex:
class Developer(Emp):
    pass

hari = Developer("hari","mantry")
- it works as you are not overridiing  __init__ in Developer class
- if you re-define __init__ in child class then, have to explicitly call parent calss function.
- you you want tot tally revamp the new method (method over loading), in this case no need to call the parent class method.
_ init on any method, input can be anything, not only number or string. we can ad emp obj or any object even hot object.
- think of fully object, dont thing only number or string







